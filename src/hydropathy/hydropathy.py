from pathlib import Path
import time
import numpy as np
import pandas as pd
import tqdm


class WaterAngles:
    """
    """
    def __init__(self, input_path, output_path, water_model):
        self.input_path = input_path
        self.output_path = output_path
        self.water_model = water_model

    def build_tetrahedron(self, coord_o, coord_h1, coord_h2):
        """
        Given the coordinates of the water molecules of a system, defines 
        the tetrahedron which has the oxygen atom itself as its center and 
        the hydrogen atom as its two vertices.

        Parameters
        ----------
        ``coord_o``: ndarray
            coordinates of the water molecule oxygen (N x 3)
        ``coord_h1``: ndarray
            coordinates of the first hydrogen atom of water molecules (N x 3)
        ``coord_h2``: ndarray
            coordinates of the second hydrogen atom of water molecules (N x 3)
        ``water_model``: the chosen water model (tip3p, tip4p, tip5p or spc)

        Returns
        -------
        the coordinates of the center (oxygen) and of the 4 vertices 
        (h1, h2 and virtual h3, h4) of the tetrahedron
        ``coord_o``: ndarray
        ``coord_h1``: ndarray
        ``coord_h2``: ndarray
        ``coord_h3``: ndarray
        ``coord_h4``: ndarray
        """
        if self.water_model == 'spc':
            scale_factor = 1
        elif self.water_model in ['tip3p', 'tip4p', 'tip5p']:
            scale_factor = 1.095585
        else:
            pass 

        # vectors OH1 and OH2
        v_oh1 = coord_h1 - coord_o
        v_oh2 = coord_h2 - coord_o

        # opposite of the midpoint between the two known vertices
        p_mid = - (v_oh1 + v_oh2) / 2

        # vector connecting hydrogens
        v_hh = coord_h2 - coord_h1

        # midpoint of the straight line connecting the two unknown vertices
        v_h1b = p_mid + coord_o

        # plane normal vector generated by vectors OH1 and OH2
        v_n = np.cross(v_oh1, v_oh2)

        # norm of half lp-lp and normal vector
        mod_hh = 0.5 * np.sqrt(np.sum(v_hh ** 2)) * scale_factor
        mod_v_n = np.sqrt(np.sum(v_n ** 2))

        # coordinates of unknown vertices
        coord_h3 = v_n / mod_v_n * mod_hh + v_h1b
        coord_h4 = - v_n / mod_v_n * mod_hh + v_h1b

        return coord_o, coord_h1, coord_h2, coord_h3, coord_h4

    @staticmethod
    def calculate_angle(v1, v2):
        """
        Given two n-dimensional vectors returns the angle expressed in degrees
        
        Parameters
        ----------
        ``v1``: ndarray
            first vector
        ``v2``: ndarray
            second vector
        
        Returns
        -------
        ``angle``: float
        """
        angle = np.arccos(np.sum(v1*v2, axis=1) / (np.sqrt(np.sum(v1**2, axis=1)) *
                                                np.sqrt(np.sum(v2**2, axis=1)))) * 180 / np.pi
        return angle

    @staticmethod
    def read_pdb(pdb):
        """
        Read a pdb file and return a list of atoms.
        Parameters
        ----------
        ``pdb``: pdb file
            the starting structure in pdb format
        
        Returns
        -------
        ``df_pdb``: pandas dataframe
            the pdb dataframe
        """
        colspecs = [(0, 6), (6, 11), (12, 16), (16, 17), (17, 20), (21, 22), (22, 26),
                (26, 27), (30, 38), (38, 46), (46, 54), (54, 60), (60, 66), (72, 76), (76, 78),
                (78, 80)]

        bionames = ['type', 'eleno', 'elety', 'alt', 'resid', 'chain', 'resno', 
                    'insert', 'x', 'y', 'z', 'o', 'b', 'segid', 'elesy', 'charge']
            
        df_pdb = pd.read_fwf(pdb, names=bionames, colspecs=colspecs)
        is_atom = df_pdb['type'].str.contains('ATOM') == True
        df_pdb = df_pdb[is_atom]
        df_pdb[['eleno', 'resno']] = df_pdb[['eleno', 'resno']].astype(int)
        df_pdb[['x', 'y', 'z']] = df_pdb[['x', 'y', 'z']].astype(float)
        return df_pdb
    
    def create_output_files(self, res_list):
        """
        Given a list of residues, create a csv for each residue with columns 
        distance, theta1, theta2, theta3, theta4, theta_d

        Parameters
        ----------
        ``res_list``: str
            list of residues written as resno_resname
        """
        for res in res_list:
            with open(Path(self.output_path).joinpath(f'{res}.csv'), 'w') as f:
                f.write("distance,theta1,theta2,theta3,theta4,theta_d\n")

    def write_and_save_files(self, data, df_residues):
        """
        Write data to csv with columns distance, theta1, theta2, theta3, theta4, theta_d.
        The data are structured as
        [[raw_11], [raw_12], [raw_13] ...], [[raw_21], [raw_22], [raw_23] ...]
        where in raw_13, 1 is residue number, 3 is the third raw with the same residue number

        Parameters
        ----------
        ``data``: ndarray
            two-dimensional numpy array
        ``df_residues``: DataFrame
            pandas data frame with columns resno and residues
        """
        # sort data by atom index
        sort_data = data[np.argsort(data[:, 0])]

        # select residue number relative to atom index
        res_num_e = df_residues['resno'][sort_data[:, 0]]
        res_num_e = np.array(res_num_e)

        # replace atom index with residue number in the first column
        sort_data[:, 0] = res_num_e

        # array ordered by residue number. Structure:
        # raw_n = [res_num, distance, theta1, theta2, theta3, theta4, theta_d]
        # sub-array [[raw_11], [raw_12], [raw_13] ...], [[raw_21], [raw_22], [raw_23] ...]
        # where in raw_13, 1 is residue number, 3 is the third raw with the same residue number
        list_array = ([sort_data[sort_data[:, 0] == k] for k in np.unique(sort_data[:, 0])])
        
        # [0, 0] refers to residue, nucleotide or lig number
        for la in list_array:
            file_name = (df_residues[df_residues['resno'] == la[0, 0]]['residue'].values[0])
            with open(Path(self.output_path).joinpath(f'{file_name}.csv'), 'a') as fw:
                np.savetxt(fw, la[:, 1:], delimiter=',', fmt='%10f')
    
    def get_angles(self):
        """
        Calculate: 
        - The distance formed between the solute atom and the oxygen atom 
        of a water molecule
        - the angles formed between the vector joining the solute atom and 
        the oxygen atom (center of the tetrahedron) and the vectors joining 
        the center and the vertices of the tetrahedron.

        Writes the data for each solute residue to a dedicated file
        """
        # filled later with: file_name, distance and 5 angles
        # a 1600000 x 7 numpy array takes up about 90MB
        data_matrix = np.zeros((1600000, 7))

        # list of pdb files
        list_files = list(Path(self.input_path).iterdir())

        start_time = time.time()
        df_pdb_base = self.read_pdb(Path(self.input_path).joinpath(list_files[0]))
        
        df_pdb_base = df_pdb_base.query('resid != "SOL"').query('elety != resid')
        df_pdb_base['residue'] = df_pdb_base['resno'].astype(str) + '_' + df_pdb_base['resid']

        # self.create_output_files(res_list)
        
        # # NOTE: we call 'solute' anything that is not an ion or a solvent: 
        # # proteins, nucleotides, ligands, ...
        # # select solute index (all heavy atoms)
        # solute_index = df_pdb[df_pdb["elety"] != "H"].index
        
        for filename in tqdm.tqdm(list_files):
            df_pdb = self.read_pdb(Path(self.input_path).joinpath(filename))
            solute_mask = (
                (df_pdb['resid'] != 'SOL') & (df_pdb['elety'] != df_pdb['resid']) & (df_pdb['elesy'] != 'H')
            )
            
            df_pdb_solute = df_pdb[solute_mask]
                        
            # reduce box dimension
            x_min = df_pdb_solute['x'].min() - 6
            x_max = df_pdb_solute['x'].max() + 6
            y_min = df_pdb_solute['y'].min() - 6
            y_max = df_pdb_solute['y'].max() + 6
            z_min = df_pdb_solute['z'].min() - 6
            z_max = df_pdb_solute['z'].max() + 6

            oxigen_mask = (
                (df_pdb['elety'] == 'OW') & (df_pdb['x'].between(x_min, x_max)) & 
                (df_pdb['y'].between(y_min, y_max)) & (df_pdb['z'].between(z_min, z_max))
            )
            
            # coordinates
            coord_o = df_pdb[oxigen_mask][['x', 'y', 'z']].to_numpy()
            coord_solute = df_pdb[solute_mask][['x', 'y', 'z']].to_numpy()

            # calculate all distances between water oxygen and solute atoms
            all_dist_oa = np.linalg.norm(coord_o - coord_solute[:, np.newaxis], axis=2)

            # select min on columns with a value lower than 6A and relative indices
            min_all_dist_oa = all_dist_oa[(all_dist_oa == np.min(all_dist_oa, axis=0)) & (all_dist_oa < 6)]
            min_indexes = np.where((all_dist_oa == np.min(all_dist_oa, axis=0)) & (all_dist_oa < 6))
            
            ox_indexes = np.take(df_pdb[oxigen_mask].index, min_indexes[1])
            coord_o_fil = df_pdb.loc[ox_indexes][['x', 'y', 'z']].to_numpy()
            coord_h1_fil = df_pdb.loc[ox_indexes + 1][['x', 'y', 'z']].to_numpy()
            coord_h2_fil = df_pdb.loc[ox_indexes + 2][['x', 'y', 'z']].to_numpy()

            # generate tetrahedron
            center, ver1, ver2, ver3, ver4 = self.build_tetrahedron(coord_o_fil, coord_h1_fil, coord_h2_fil)

            # define vectors from the center of the tetrahedron to four vertices
            oh1 = ver1 - center
            oh2 = ver2 - center
            oh3 = ver3 - center
            oh4 = ver4 - center
            dipole = oh1 + oh2

            # define vector from heavy atoms of the solute to the center of the nearest tetrahedron
            v_axis = center - coord_solute[min_indexes[0]]

            # calculate angles
            theta1 = self.calculate_angle(oh1, v_axis)
            theta2 = self.calculate_angle(oh2, v_axis)
            theta3 = self.calculate_angle(oh3, v_axis)
            theta4 = self.calculate_angle(oh4, v_axis)
            theta_d = self.calculate_angle(dipole, v_axis)

            # put all data in a matrix
            row_data = np.column_stack((np.take(df_pdb_solute.index, min_indexes[0]),
                                        min_all_dist_oa, theta1, theta2, theta3, theta4, theta_d))

            # fill big matrix 1600000 x 7 with row_data
            # data_matrix[np.where(data_matrix == 0)[0][0]:np.where(data_matrix == 0)[0][0] + np.shape(row_data)[0], :] = row_data
            index_from = np.where(~data_matrix.any(axis=1))[0].min()
            index_to = np.where(~data_matrix.any(axis=1))[0].min() + np.shape(row_data)[0]
            data_matrix[index_from:index_to, :] = row_data

            # write and save data if non zero elements of data_matrix are more then 80MB
            non_null = data_matrix[np.where(data_matrix != 0)]
            if non_null.size * non_null.itemsize / 10 ** 6 > 80:
                data_matrix = data_matrix[~np.all(data_matrix == 0, axis=1)]
                self.write_and_save_files(data_matrix, df_pdb_base[['resno', 'residue']])
                data_matrix = np.zeros((1600000, 7))
        
        # write and save data if non zero elements of data_matrix at the end of for-loop are less then 80MB
        data_matrix = data_matrix[~np.all(data_matrix == 0, axis=1)]
        self.write_and_save_files(data_matrix, df_pdb_base[['resno', 'residue']])

        end_time = time.time()
        return end_time - start_time

